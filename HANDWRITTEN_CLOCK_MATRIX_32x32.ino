//************************************************************************************************************//
  
//*************** HANDWRITTEN CLOCK - 32x32 BICOLOR LED MATRIX USING BIT ANGLE MODULATION METHOD *************//

//************************************************************************************************************//
#include <SPI.h>
#include "Wire.h"
#include <avr/pgmspace.h>

// REAL PIN ON ARDUINO

#define blank_pin       3   // BLANK PIN - 74HC595
#define latch_pin       2   // LATCH PIN - 74HC595
#define clock_pin       52  // CLOCK PIN - 74HC595
#define data_pin        51  // DATA PIN - 74HC595


#define RowA_Pin        22  // A PIN - 74HC238
#define RowB_Pin        24  // B PIN - 74HC238
#define RowC_Pin        26  // C PIN - 74HC238
#define RowD_Pin        28  // D PIN - 74HC238
//#define OE_Pin        30  // ENABLE OUTPUT PIN - 74HC238

//MAPPING TO PORT

#define Blank_Pin_Bit   5 // PORTE bit 5 - PE5
#define Latch_Pin_Bit   4 // PORTE bit 4 - PE4

#define RowA_Pin_Bit    0 // PORTA bit 0 - PA0
#define RowB_Pin_Bit    2 // PORTA bit 2 - PA2
#define RowC_Pin_Bit    4 // PORTA bit 4 - PA4
#define RowD_Pin_Bit    6 // PORTA bit 6 - PA6
#define OE_Pin_Bit      7 // PORTC bit 7 - PC7

/**   An RG color template */
struct Color
{
  unsigned char red, green;

  Color(int r, int g) : red(r), green(g) {}
  Color() : red(0), green(0) {}
};

const Color redcolor       = Color(0x0F,0x00);
const Color orangecolor    = Color(0x0F,0x0F);
const Color yellowcolor    = Color(0x0F,0x09);
const Color greencolor     = Color(0x00,0x0F);
const Color clearcolor     = Color(0x00,0x00);

const Color myRED       = Color(0x0F,0x00);
const Color myORANGE    = Color(0x0F,0x0F);
const Color myYELLOW    = Color(0x0F,0x09);
const Color myGREEN     = Color(0x00,0x0F);
const Color myCLEAR     = Color(0x00,0x00);

// *************************************************For DS3231******************************************//
#define DS3231_I2C_ADDRESS 0x68
unsigned long samplingtime = 0;
byte ssecond, sminute, shour, sdayOfWeek, sdayOfMonth, smonth, syear;
byte csecond, cminute, chour, cdayOfWeek, cdayOfMonth, cmonth, cyear;
byte s0, s1, m0, m1, h0, h1;
byte prves0, prves1, prvem0, prvem1, prveh0, prveh1;

//************************************************************************************************************//

#define myPI                  3.14159265358979323846
#define myDPI                 1.2732395
#define myDPI2                0.40528473
#define dist(a, b, c, d)      sqrt(double((a - c) * (a - c) + (b - d) * (b - d)))
#ifndef _swap_int16_t
#define _swap_int16_t(a, b)   { int16_t t = a; a = b; b = t; }
#endif
//*************************************************ColorWheel******************************************//

#define COLOUR_WHEEL_LENGTH 128

uint8_t colourR[COLOUR_WHEEL_LENGTH];
uint8_t colourG[COLOUR_WHEEL_LENGTH];
int16_t ColPos = 0;
uint16_t colourPos;
uint8_t R, G;

//********************************************************* BAM *******************************************************//
#define BAM_RESOLUTION 4    // EG 4 bit colour = 15 variation of R, G (256 colours)

const  byte Size_Y = 32;    //Number of LEDS in Y axis (Top to Bottom)
const  byte Size_X = 32;    //Number of LEDs in X axis (Left to Right)

byte red[4][128];
byte green[4][128];

int level=0;                //keeps track of which level we are shifting data to
int row=0;
int BAM_Bit, BAM_Counter=0; // Bit Angle Modulation variables to keep track of things

#define RED     0x0F,0x00
#define ORANGE  0x0F,0x04
#define YELLOW  0x0F,0x09
#define GREEN   0x00,0x0F
#define CLEAR   0x00,0x00

//*************************************************** HANDWRITTEN DATA *************************************************//
#define BIG_NUMBER    2
#define INV_NUMBER    1
#define SMALL_NUMBER  0

// Handwritten small number data, font size 7x11

const byte * const Zero[42][2] PROGMEM  = {{4, 1},{3, 1},{3, 2},{2, 2},{2, 3},{1, 3},{1, 4},{2, 4},{2, 5},{1, 5},{1, 6},{2, 6},{2, 7},{1, 7},{1, 8},{2, 8},{2, 9},{1, 9},{2, 10},{3, 10},{3, 11},{4, 11},{5, 11},{5, 10},{6, 10},{7, 9},{6, 9},{6, 8},{7, 8},{7, 7},{6, 7},{6, 6},{7, 6},{7, 5},{6, 5},{7, 4},{6, 4},{6, 3},{7, 3},{6, 2},{5, 2},{5, 1}};   //0
const byte * const One[28][2] PROGMEM  = {{1, 2},{2, 2},{3, 1},{4, 1},{4, 2},{3, 2},{3, 3},{4, 3},{3, 4},{4, 4},{4, 5},{3, 5},{3, 6},{4, 6},{4, 7},{3, 7},{3, 8},{4, 8},{4, 9},{3, 9},{3, 10},{4, 10},{1, 11},{2, 11},{3, 11},{4, 11},{5, 11},{6, 11}};   //1
const byte * const Two[38][2] PROGMEM  = {{2, 4},{1, 4},{1, 3},{2, 3},{2, 2},{1, 2},{2, 1},{3, 1},{4, 1},{5, 1},{6, 1},{6, 2},{7, 2},{7, 3},{6, 3},{6, 4},{7, 4},{6, 5},{5, 5},{6, 6},{5, 6},{5, 7},{4, 7},{4, 8},{3, 8},{3, 9},{2, 9},{2, 10},{1, 10},{1, 11},{2, 11},{3, 11},{4, 11},{5, 11},{6, 11},{7, 11},{7, 10},{6, 10}};   //2
const byte * const Three[36][2] PROGMEM  = {{2, 3},{1, 3},{1, 2},{2, 2},{2, 1},{3, 1},{4, 1},{5, 1},{6, 1},{7, 2},{6, 2},{6, 3},{7, 3},{6, 4},{5, 4},{3, 5},{4, 5},{5, 5},{5, 6},{6, 6},{6, 7},{7, 7},{7, 8},{6, 8},{6, 9},{7, 9},{6, 10},{5, 10},{5, 11},{4, 11},{3, 11},{2, 11},{2, 10},{1, 10},{1, 9},{2, 9}};   //3
const byte * const Four[41][2] PROGMEM  = {{4, 2},{4, 3},{3, 3},{2, 4},{3, 4},{3, 5},{2, 5},{2, 6},{1, 6},{1, 7},{2, 7},{1, 8},{2, 8},{3, 8},{4, 8},{5, 8},{6, 8},{7, 8},{5, 1},{6, 1},{6, 2},{5, 2},{5, 3},{6, 3},{6, 4},{5, 4},{5, 5},{6, 5},{6, 6},{5, 6},{5, 7},{6, 7},{6, 9},{5, 9},{5, 10},{6, 10},{3, 11},{4, 11},{5, 11},{6, 11},{7, 11}};   //4
const byte * const Five[39][2] PROGMEM  = {{7, 1},{6, 1},{5, 1},{4, 1},{3, 1},{2, 1},{1, 1},{1, 2},{2, 2},{2, 3},{1, 3},{1, 4},{2, 4},{1, 5},{1, 6},{2, 6},{2, 5},{3, 5},{3, 6},{4, 5},{5, 5},{5, 6},{6, 6},{6, 7},{7, 7},{7, 8},{6, 8},{6, 9},{7, 9},{6, 10},{5, 10},{5, 11},{4, 11},{3, 11},{2, 11},{2, 10},{2, 9},{1, 9},{1, 10}};   //5
const byte * const Six[41][2] PROGMEM  = {{5, 2},{6, 2},{6, 1},{5, 1},{4, 1},{3, 1},{3, 2},{2, 2},{2, 3},{1, 3},{1, 4},{2, 4},{2, 5},{1, 5},{1, 6},{2, 6},{2, 7},{1, 7},{1, 8},{2, 8},{2, 9},{1, 9},{2, 10},{3, 10},{3, 11},{4, 11},{5, 11},{5, 10},{6, 10},{6, 9},{7, 9},{7, 8},{6, 8},{6, 7},{7, 7},{6, 6},{5, 6},{5, 5},{4, 5},{3, 5},{3, 6}};   //6
const byte * const Seven[31][2] PROGMEM  = {{2, 3},{1, 3},{1, 2},{2, 2},{1, 1},{2, 1},{3, 1},{4, 1},{5, 1},{6, 1},{7, 1},{6, 2},{5, 2},{5, 3},{6, 3},{5, 4},{4, 4},{4, 5},{5, 5},{4, 6},{3, 6},{3, 7},{4, 7},{4, 8},{3, 8},{3, 9},{4, 9},{4, 10},{3, 10},{3, 11},{4, 11}};   //7
const byte * const Eight[45][2] PROGMEM  = {{5, 5},{6, 5},{6, 4},{7, 4},{7, 3},{6, 3},{6, 2},{7, 2},{6, 1},{5, 1},{4, 1},{3, 1},{2, 1},{1, 2},{2, 2},{2, 3},{1, 3},{1, 4},{2, 4},{2, 5},{3, 5},{4, 6},{5, 6},{5, 7},{6, 7},{7, 8},{6, 8},{6, 9},{7, 9},{7, 10},{6, 10},{6, 11},{5, 11},{4, 11},{3, 11},{2, 11},{2, 10},{1, 10},{1, 9},{2, 9},{2, 8},{1, 8},{2, 7},{3, 7},{3, 6}};   //8
const byte * const Nine[41][2] PROGMEM  = {{5, 6},{5, 7},{4, 7},{3, 7},{3, 6},{2, 6},{2, 5},{1, 5},{1, 4},{2, 4},{2, 3},{1, 3},{2, 2},{3, 2},{3, 1},{4, 1},{5, 1},{5, 2},{6, 2},{6, 3},{7, 3},{7, 4},{6, 4},{6, 5},{7, 5},{7, 6},{6, 6},{6, 7},{7, 7},{7, 8},{6, 8},{6, 9},{7, 9},{6, 10},{5, 10},{5, 11},{4, 11},{3, 11},{2, 11},{2, 10},{3, 10}};   //9
const byte * const Delete[39][2] PROGMEM  = {{1, 1},{1, 3},{2, 2},{3, 1},{5, 1},{4, 2},{3, 3},{2, 4},{1, 5},{1, 7},{2, 6},{3, 5},{4, 4},{5, 3},{6, 2},{7, 1},{7, 3},{6, 4},{5, 5},{4, 6},{3, 7},{2, 8},{1, 9},{1, 11},{2, 10},{3, 9},{4, 8},{5, 7},{6, 6},{7, 5},{7, 7},{6, 8},{5, 9},{4, 10},{3, 11},{5, 11},{6, 10},{7, 9},{7, 11}};   //Delete

// Handwritten small inverted number data, font size 8x16

const byte * const Inv_Zero[86][2] PROGMEM = {{0, 0},{1, 0},{0, 1},{0, 2},{1, 1},{2, 0},{3, 0},{2, 1},{1, 2},{0, 3},{0, 4},{4, 0},{5, 0},{0, 5},{0, 6},{3, 3},{4, 2},{6, 0},{7, 0},{6, 1},{4, 3},{3, 4},{0, 7},{0, 8},{3, 5},{4, 4},{5, 3},{7, 1},{7, 2},{5, 4},{4, 5},{3, 6},{0, 9},{0, 10},{3, 7},{4, 6},{5, 5},{5, 6},{4, 7},{3, 8},{1, 10},{0, 11},{0, 12},{1, 11},{3, 9},{4, 8},{5, 7},{5, 8},{4, 9},{2, 11},{1, 12},{0, 13},{0, 14},{1, 13},{2, 12},{4, 10},{5, 9},{3, 12},{2, 13},{1, 14},{0, 15},{1, 15},{2, 14},{3, 13},{4, 12},{7, 10},{6, 11},{5, 12},{4, 13},{3, 14},{2, 15},{3, 15},{4, 14},{5, 13},{6, 12},{7, 11},{7, 12},{6, 13},{5, 14},{4, 15},{5, 15},{6, 14},{7, 13},{7, 14},{6, 15},{7, 15}}; //Inv_0
const byte * const Inv_One[100][2] PROGMEM  = {{0, 0},{1, 0},{0, 1},{0, 2},{1, 1},{2, 0},{3, 0},{2, 1},{0, 3},{0, 4},{1, 3},{4, 0},{5, 0},{2, 3},{1, 4},{0, 5},{0, 6},{1, 5},{2, 4},{5, 1},{6, 0},{7, 0},{6, 1},{5, 2},{2, 5},{1, 6},{0, 7},{0, 8},{1, 7},{2, 6},{5, 3},{6, 2},{7, 1},{7, 2},{6, 3},{5, 4},{2, 7},{1, 8},{0, 9},{0, 10},{1, 9},{2, 8},{5, 5},{6, 4},{7, 3},{7, 4},{6, 5},{5, 6},{2, 9},{1, 10},{0, 11},{0, 12},{2, 10},{5, 7},{6, 6},{7, 5},{7, 6},{6, 7},{5, 8},{1, 12},{0, 13},{0, 14},{1, 13},{2, 12},{5, 9},{6, 8},{7, 7},{7, 8},{6, 9},{5, 10},{3, 12},{2, 13},{1, 14},{0, 15},{1, 15},{2, 14},{3, 13},{4, 12},{6, 10},{7, 9},{7, 10},{5, 12},{4, 13},{3, 14},{2, 15},{3, 15},{4, 14},{5, 13},{6, 12},{7, 11},{7, 12},{6, 13},{5, 14},{4, 15},{5, 15},{6, 14},{7, 13},{7, 14},{6, 15},{7, 15}}; //Inv_1
const byte * const Inv_Two[90][2] PROGMEM  = {{0, 0},{1, 0},{0, 1},{0, 2},{1, 1},{2, 0},{3, 0},{0, 3},{0, 4},{4, 0},{5, 0},{3, 2},{0, 5},{0, 6},{1, 5},{3, 3},{4, 2},{6, 0},{7, 0},{5, 2},{4, 3},{3, 4},{2, 5},{1, 6},{0, 7},{0, 8},{1, 7},{2, 6},{3, 5},{4, 4},{5, 3},{7, 1},{5, 4},{4, 5},{3, 6},{2, 7},{1, 8},{0, 9},{0, 10},{1, 9},{2, 8},{3, 7},{4, 6},{0, 11},{0, 12},{7, 5},{7, 6},{6, 7},{5, 8},{4, 9},{3, 10},{1, 12},{0, 13},{0, 14},{1, 13},{2, 12},{4, 10},{5, 9},{6, 8},{7, 7},{7, 8},{6, 9},{5, 10},{3, 12},{2, 13},{1, 14},{0, 15},{1, 15},{2, 14},{3, 13},{4, 12},{7, 9},{5, 12},{4, 13},{3, 14},{2, 15},{3, 15},{4, 14},{5, 13},{6, 12},{7, 12},{6, 13},{5, 14},{4, 15},{5, 15},{6, 14},{7, 13},{7, 14},{6, 15},{7, 15}}; //Inv_2
const byte * const Inv_Three[92][2] PROGMEM  = {{0, 0},{1, 0},{0, 1},{0, 2},{1, 1},{2, 0},{3, 0},{0, 3},{0, 4},{4, 0},{5, 0},{3, 2},{1, 4},{0, 5},{0, 6},{1, 5},{2, 4},{3, 3},{4, 2},{6, 0},{7, 0},{5, 2},{4, 3},{3, 4},{2, 5},{1, 6},{0, 7},{0, 8},{1, 7},{2, 6},{4, 4},{5, 3},{7, 1},{3, 6},{2, 7},{1, 8},{0, 9},{0, 10},{2, 8},{3, 7},{4, 6},{7, 4},{6, 5},{4, 7},{3, 8},{0, 11},{0, 12},{1, 11},{3, 9},{4, 8},{5, 7},{7, 5},{7, 6},{5, 8},{4, 9},{3, 10},{1, 12},{0, 13},{0, 14},{1, 13},{2, 12},{4, 10},{5, 9},{3, 12},{2, 13},{1, 14},{0, 15},{1, 15},{2, 14},{3, 13},{4, 12},{7, 10},{6, 11},{5, 12},{4, 13},{3, 14},{2, 15},{3, 15},{4, 14},{5, 13},{6, 12},{7, 11},{7, 12},{6, 13},{5, 14},{4, 15},{5, 15},{6, 14},{7, 13},{7, 14},{6, 15},{7, 15}}; //Inv_3
const byte * const Inv_Four[87][2] PROGMEM  = {{0, 0},{1, 0},{0, 1},{0, 2},{1, 1},{2, 0},{3, 0},{2, 1},{1, 2},{0, 3},{0, 4},{1, 3},{2, 2},{3, 1},{4, 0},{5, 0},{4, 1},{3, 2},{2, 3},{1, 4},{0, 5},{0, 6},{1, 5},{6, 0},{7, 0},{0, 7},{0, 8},{4, 4},{7, 1},{7, 2},{4, 5},{3, 6},{0, 9},{0, 10},{1, 9},{3, 7},{4, 6},{7, 3},{7, 4},{4, 7},{2, 9},{1, 10},{0, 11},{0, 12},{1, 11},{2, 10},{3, 9},{7, 5},{7, 6},{4, 9},{3, 10},{2, 11},{1, 12},{0, 13},{0, 14},{1, 13},{2, 12},{4, 10},{7, 7},{3, 12},{2, 13},{1, 14},{0, 15},{1, 15},{2, 14},{3, 13},{4, 12},{7, 9},{7, 10},{5, 12},{4, 13},{3, 14},{2, 15},{3, 15},{4, 14},{5, 13},{6, 12},{7, 12},{6, 13},{5, 14},{4, 15},{5, 15},{6, 14},{7, 13},{7, 14},{6, 15},{7, 15}}; //Inv_4
const byte * const Inv_Five[89][2] PROGMEM  = {{0, 0},{1, 0},{0, 1},{0, 2},{2, 0},{3, 0},{0, 3},{0, 4},{4, 0},{5, 0},{3, 2},{0, 5},{0, 6},{3, 3},{4, 2},{6, 0},{7, 0},{5, 2},{4, 3},{3, 4},{0, 7},{0, 8},{1, 7},{4, 4},{5, 3},{6, 2},{7, 2},{6, 3},{5, 4},{2, 7},{1, 8},{0, 9},{0, 10},{2, 8},{3, 7},{4, 6},{6, 4},{7, 3},{7, 4},{6, 5},{4, 7},{3, 8},{0, 11},{0, 12},{1, 11},{3, 9},{4, 8},{5, 7},{7, 5},{7, 6},{5, 8},{4, 9},{3, 10},{1, 12},{0, 13},{0, 14},{1, 13},{2, 12},{4, 10},{5, 9},{3, 12},{2, 13},{1, 14},{0, 15},{1, 15},{2, 14},{3, 13},{4, 12},{7, 10},{6, 11},{5, 12},{4, 13},{3, 14},{2, 15},{3, 15},{4, 14},{5, 13},{6, 12},{7, 11},{7, 12},{6, 13},{5, 14},{4, 15},{5, 15},{6, 14},{7, 13},{7, 14},{6, 15},{7, 15}}; //Inv_5
const byte * const Inv_Six[87][2] PROGMEM  = {{0, 0},{1, 0},{0, 1},{0, 2},{1, 1},{2, 0},{3, 0},{2, 1},{1, 2},{0, 3},{0, 4},{4, 0},{5, 0},{0, 5},{0, 6},{3, 3},{4, 2},{6, 0},{7, 0},{4, 3},{3, 4},{0, 7},{0, 8},{4, 4},{5, 3},{7, 1},{7, 2},{6, 3},{5, 4},{0, 9},{0, 10},{3, 7},{4, 6},{6, 4},{7, 3},{7, 4},{6, 5},{4, 7},{3, 8},{1, 10},{0, 11},{0, 12},{1, 11},{3, 9},{4, 8},{5, 7},{7, 5},{7, 6},{5, 8},{4, 9},{2, 11},{1, 12},{0, 13},{0, 14},{1, 13},{2, 12},{5, 9},{4, 10},{3, 12},{2, 13},{1, 14},{0, 15},{1, 15},{2, 14},{3, 13},{4, 12},{7, 10},{6, 11},{5, 12},{4, 13},{3, 14},{2, 15},{3, 15},{4, 14},{5, 13},{6, 12},{7, 11},{7, 12},{6, 13},{5, 14},{4, 15},{5, 15},{6, 14},{7, 13},{7, 14},{6, 15},{7, 15}}; //Inv_6
const byte * const Inv_Seven[97][2] PROGMEM  = {{0, 0},{1, 0},{0, 1},{0, 2},{2, 0},{3, 0},{0, 3},{0, 4},{4, 0},{5, 0},{3, 2},{1, 4},{0, 5},{0, 6},{1, 5},{2, 4},{3, 3},{4, 2},{6, 0},{7, 0},{4, 3},{3, 4},{2, 5},{1, 6},{0, 7},{0, 8},{1, 7},{2, 6},{3, 5},{7, 2},{2, 7},{1, 8},{0, 9},{0, 10},{1, 9},{2, 8},{6, 4},{7, 3},{7, 4},{6, 5},{5, 6},{2, 9},{1, 10},{0, 11},{0, 12},{1, 11},{2, 10},{5, 7},{6, 6},{7, 5},{7, 6},{6, 7},{5, 8},{2, 11},{1, 12},{0, 13},{0, 14},{1, 13},{2, 12},{5, 9},{6, 8},{7, 7},{7, 8},{6, 9},{5, 10},{3, 12},{2, 13},{1, 14},{0, 15},{1, 15},{2, 14},{3, 13},{4, 12},{5, 11},{6, 10},{7, 9},{7, 10},{6, 11},{5, 12},{4, 13},{3, 14},{2, 15},{3, 15},{4, 14},{5, 13},{6, 12},{7, 11},{7, 12},{6, 13},{5, 14},{4, 15},{5, 15},{6, 14},{7, 13},{7, 14},{6, 15},{7, 15}}; //Inv_7
const byte * const Inv_Eight[83][2] PROGMEM  = {{0, 0},{1, 0},{0, 1},{0, 2},{1, 1},{2, 0},{3, 0},{0, 3},{0, 4},{4, 0},{5, 0},{3, 2},{0, 5},{0, 6},{1, 5},{3, 3},{4, 2},{6, 0},{7, 0},{5, 2},{4, 3},{3, 4},{1, 6},{0, 7},{0, 8},{1, 7},{2, 6},{4, 4},{5, 3},{7, 1},{5, 4},{4, 5},{0, 9},{0, 10},{4, 7},{3, 8},{0, 11},{0, 12},{1, 11},{3, 9},{4, 8},{6, 6},{7, 5},{7, 6},{5, 8},{4, 9},{3, 10},{1, 12},{0, 13},{0, 14},{1, 13},{2, 12},{4, 10},{5, 9},{7, 7},{5, 10},{3, 12},{2, 13},{1, 14},{0, 15},{1, 15},{2, 14},{3, 13},{4, 12},{5, 12},{4, 13},{3, 14},{2, 15},{3, 15},{4, 14},{5, 13},{6, 12},{7, 11},{7, 12},{6, 13},{5, 14},{4, 15},{5, 15},{6, 14},{7, 13},{7, 14},{6, 15},{7, 15}}; //Inv_8
const byte * const Inv_Nine[87][2] PROGMEM  = {{0, 0},{1, 0},{0, 1},{0, 2},{1, 1},{2, 0},{3, 0},{2, 1},{1, 2},{0, 3},{0, 4},{4, 0},{5, 0},{0, 5},{0, 6},{3, 3},{4, 2},{6, 0},{7, 0},{6, 1},{4, 3},{3, 4},{1, 6},{0, 7},{0, 8},{1, 7},{3, 5},{4, 4},{5, 3},{7, 1},{7, 2},{5, 4},{4, 5},{2, 7},{1, 8},{0, 9},{0, 10},{1, 9},{2, 8},{4, 6},{5, 5},{3, 8},{2, 9},{1, 10},{0, 11},{0, 12},{1, 11},{3, 9},{4, 8},{5, 8},{4, 9},{1, 12},{0, 13},{0, 14},{1, 13},{2, 12},{4, 10},{5, 9},{3, 12},{2, 13},{1, 14},{0, 15},{1, 15},{2, 14},{3, 13},{4, 12},{7, 10},{6, 11},{5, 12},{4, 13},{3, 14},{2, 15},{3, 15},{4, 14},{5, 13},{6, 12},{7, 11},{7, 12},{6, 13},{5, 14},{4, 15},{5, 15},{6, 14},{7, 13},{7, 14},{6, 15},{7, 15}}; //Inv_9
const byte * const Inv_Delete[128][2] PROGMEM  = {{0, 0},{1, 0},{0, 1},{0, 2},{1, 1},{2, 0},{3, 0},{2, 1},{1, 2},{0, 3},{0, 4},{1, 3},{2, 2},{3, 1},{4, 0},{5, 0},{4, 1},{3, 2},{2, 3},{1, 4},{0, 5},{0, 6},{1, 5},{2, 4},{3, 3},{4, 2},{5, 1},{6, 0},{7, 0},{6, 1},{5, 2},{4, 3},{3, 4},{2, 5},{1, 6},{0, 7},{0, 8},{1, 7},{2, 6},{3, 5},{4, 4},{5, 3},{6, 2},{7, 1},{7, 2},{6, 3},{5, 4},{4, 5},{3, 6},{2, 7},{1, 8},{0, 9},{0, 10},{1, 9},{2, 8},{3, 7},{4, 6},{5, 5},{6, 4},{7, 3},{7, 4},{6, 5},{5, 6},{4, 7},{3, 8},{2, 9},{1, 10},{0, 11},{0, 12},{1, 11},{2, 10},{3, 9},{4, 8},{5, 7},{6, 6},{7, 5},{7, 6},{6, 7},{5, 8},{4, 9},{3, 10},{2, 11},{1, 12},{0, 13},{0, 14},{1, 13},{2, 12},{3, 11},{4, 10},{5, 9},{6, 8},{7, 7},{7, 8},{6, 9},{5, 10},{4, 11},{3, 12},{2, 13},{1, 14},{0, 15},{1, 15},{2, 14},{3, 13},{4, 12},{5, 11},{6, 10},{7, 9},{7, 10},{6, 11},{5, 12},{4, 13},{3, 14},{2, 15},{3, 15},{4, 14},{5, 13},{6, 12},{7, 11},{7, 12},{6, 13},{5, 14},{4, 15},{5, 15},{6, 14},{7, 13},{7, 14},{6, 15},{7, 15}}; //Inv_10

// Handwritten big number data, font size 14x20

const byte * const Big_Zero[192][2] PROGMEM = {{6, 5},{6, 4},{5, 4},{5, 5},{5, 6},{4, 7},{4, 6},{4, 5},{4, 4},{3, 4},{2, 5},{1, 6},{0, 7},{0, 8},{1, 7},{2, 6},{3, 5},{3, 6},{2, 7},{1, 8},{0, 9},{0, 10},{1, 9},{2, 8},{3, 7},{3, 8},{2, 9},{1, 10},{0, 11},{0, 12},{1, 11},{2, 10},{3, 9},{3, 10},{2, 11},{1, 12},{0, 13},{0, 14},{1, 13},{2, 12},{3, 11},{3, 12},{2, 13},{1, 14},{0, 15},{0, 16},{1, 15},{2, 14},{3, 13},{3, 14},{2, 15},{1, 16},{0, 17},{0, 18},{1, 17},{2, 16},{3, 15},{3, 16},{2, 17},{1, 18},{0, 19},{0, 20},{1, 19},{2, 18},{3, 17},{3, 18},{2, 19},{1, 20},{1, 21},{2, 20},{3, 19},{3, 20},{2, 21},{2, 22},{3, 21},{4, 20},{4, 21},{3, 22},{3, 23},{4, 22},{5, 21},{5, 22},{4, 23},{5, 23},{6, 22},{7, 22},{6, 23},{7, 23},{8, 23},{8, 22},{8, 21},{9, 20},{9, 21},{9, 22},{9, 23},{10, 23},{11, 22},{12, 21},{13, 20},{13, 19},{12, 20},{11, 21},{10, 22},{10, 21},{11, 20},{12, 19},{13, 18},{13, 17},{12, 18},{11, 19},{10, 20},{10, 19},{11, 18},{12, 17},{13, 16},{13, 15},{12, 16},{11, 17},{10, 18},{10, 17},{11, 16},{12, 15},{13, 14},{13, 13},{12, 14},{11, 15},{10, 16},{10, 15},{11, 14},{12, 13},{13, 12},{13, 11},{12, 12},{11, 13},{10, 14},{10, 13},{11, 12},{12, 11},{13, 10},{13, 9},{12, 10},{11, 11},{10, 12},{10, 11},{11, 10},{12, 9},{13, 8},{13, 7},{12, 8},{11, 9},{10, 10},{10, 9},{11, 8},{12, 7},{12, 6},{11, 7},{10, 8},{10, 7},{11, 6},{11, 5},{10, 6},{9, 7},{9, 6},{10, 5},{10, 4},{9, 5},{8, 6},{8, 5},{9, 4},{8, 4},{7, 5},{7, 4},{7, 11},{8, 12},{8, 13},{8, 14},{8, 15},{7, 16},{6, 16},{5, 15},{5, 14},{5, 13},{5, 12},{6, 11},{7, 12},{7, 13},{7, 14},{7, 15},{6, 15},{6, 14},{6, 13},{6, 12}}; //Big_0
const byte * const Big_One[106][2] PROGMEM = {{2, 8},{3, 7},{4, 6},{5, 5},{6, 4},{7, 4},{6, 5},{5, 6},{4, 7},{3, 8},{4, 8},{5, 7},{6, 6},{7, 5},{8, 4},{9, 4},{8, 5},{7, 6},{6, 7},{5, 8},{6, 8},{7, 7},{8, 6},{9, 5},{9, 6},{8, 7},{7, 8},{6, 9},{6, 10},{7, 9},{8, 8},{9, 7},{9, 8},{8, 9},{7, 10},{6, 11},{6, 12},{7, 11},{8, 10},{9, 9},{9, 10},{8, 11},{7, 12},{6, 13},{6, 14},{7, 13},{8, 12},{9, 11},{9, 12},{8, 13},{7, 14},{6, 15},{6, 16},{7, 15},{8, 14},{9, 13},{9, 14},{8, 15},{7, 16},{6, 17},{6, 18},{7, 17},{8, 16},{9, 15},{9, 16},{8, 17},{7, 18},{6, 19},{6, 20},{7, 19},{8, 18},{9, 17},{9, 18},{8, 19},{7, 20},{6, 21},{7, 21},{8, 20},{9, 19},{9, 20},{8, 21},{9, 21},{2, 23},{2, 22},{3, 22},{3, 23},{4, 23},{4, 22},{5, 22},{5, 23},{6, 23},{6, 22},{7, 22},{7, 23},{8, 23},{8, 22},{9, 22},{9, 23},{10, 23},{10, 22},{11, 22},{11, 23},{12, 23},{12, 22},{13, 22},{13, 23}}; //Big_1
const byte * const Big_Two[145][2] PROGMEM = {{0, 6},{1, 5},{2, 4},{3, 4},{2, 5},{1, 6},{0, 7},{0, 8},{1, 7},{2, 6},{3, 5},{4, 4},{5, 4},{4, 5},{3, 6},{2, 7},{1, 8},{2, 8},{3, 7},{4, 6},{5, 5},{6, 4},{7, 4},{6, 5},{7, 5},{8, 4},{9, 4},{8, 5},{9, 5},{10, 4},{11, 4},{10, 5},{9, 6},{10, 6},{11, 5},{12, 5},{11, 6},{10, 7},{10, 8},{11, 7},{12, 6},{13, 6},{12, 7},{11, 8},{10, 9},{9, 10},{8, 11},{7, 12},{6, 13},{5, 14},{4, 15},{3, 16},{2, 17},{1, 18},{0, 19},{0, 20},{1, 19},{2, 18},{3, 17},{4, 16},{5, 15},{6, 14},{7, 13},{8, 12},{9, 11},{10, 10},{11, 9},{12, 8},{13, 7},{13, 8},{12, 9},{11, 10},{10, 11},{9, 12},{8, 13},{7, 14},{6, 15},{5, 16},{4, 17},{3, 18},{2, 19},{1, 20},{0, 21},{0, 22},{1, 21},{2, 20},{3, 19},{4, 18},{5, 17},{6, 16},{7, 15},{8, 14},{9, 13},{10, 12},{11, 11},{12, 10},{13, 9},{13, 10},{12, 11},{11, 12},{10, 13},{9, 14},{8, 15},{7, 16},{6, 17},{5, 18},{4, 19},{3, 20},{2, 21},{1, 22},{0, 23},{1, 23},{2, 22},{3, 21},{3, 22},{2, 23},{3, 23},{4, 22},{5, 22},{4, 23},{5, 23},{6, 22},{7, 22},{6, 23},{7, 23},{8, 22},{9, 22},{8, 23},{9, 23},{10, 23},{10, 22},{10, 21},{10, 20},{11, 20},{11, 21},{11, 22},{11, 23},{12, 23},{12, 22},{12, 21},{12, 20},{13, 20},{13, 21},{13, 22},{13, 23}}; //Big_2
const byte * const Big_Three[136][2] PROGMEM = {{0, 6},{1, 5},{2, 4},{3, 4},{2, 5},{1, 6},{0, 7},{1, 7},{2, 6},{3, 5},{4, 4},{5, 4},{4, 5},{3, 6},{2, 7},{3, 7},{4, 6},{5, 5},{6, 4},{6, 5},{7, 5},{7, 4},{8, 4},{8, 5},{9, 6},{9, 5},{9, 4},{10, 4},{11, 4},{12, 5},{11, 5},{10, 5},{10, 6},{11, 6},{12, 6},{13, 6},{13, 7},{12, 7},{11, 7},{10, 7},{10, 8},{11, 8},{12, 8},{13, 8},{13, 9},{12, 9},{11, 9},{10, 9},{10, 10},{11, 10},{12, 10},{13, 10},{12, 11},{11, 11},{10, 11},{9, 11},{4, 12},{4, 13},{5, 13},{5, 12},{6, 12},{6, 13},{7, 13},{7, 12},{8, 12},{8, 13},{9, 14},{9, 13},{9, 12},{10, 12},{11, 12},{11, 13},{10, 13},{10, 14},{11, 14},{12, 14},{13, 15},{12, 15},{11, 15},{10, 15},{10, 16},{11, 16},{12, 16},{13, 16},{13, 17},{12, 17},{11, 17},{10, 17},{10, 18},{11, 18},{12, 18},{13, 18},{13, 19},{12, 19},{11, 19},{10, 19},{10, 20},{11, 20},{12, 20},{13, 20},{13, 21},{12, 21},{11, 21},{10, 21},{9, 21},{12, 22},{11, 22},{11, 23},{10, 23},{10, 22},{9, 22},{9, 23},{8, 23},{8, 22},{7, 22},{7, 23},{6, 23},{6, 22},{5, 22},{5, 23},{4, 23},{4, 22},{4, 21},{3, 20},{3, 21},{3, 22},{3, 23},{2, 23},{2, 22},{2, 21},{2, 20},{1, 20},{1, 21},{1, 22},{0, 21},{0, 20}}; //Big_3
const byte * const Big_Four[142][2] PROGMEM = {{7, 5},{6, 6},{5, 7},{4, 8},{3, 9},{2, 10},{1, 11},{0, 12},{0, 13},{1, 12},{2, 11},{3, 10},{4, 9},{5, 8},{6, 7},{7, 6},{7, 7},{6, 8},{5, 9},{4, 10},{3, 11},{2, 12},{1, 13},{0, 14},{0, 15},{1, 14},{2, 13},{3, 12},{4, 11},{5, 10},{6, 9},{7, 8},{7, 9},{6, 10},{5, 11},{4, 12},{3, 13},{2, 14},{1, 15},{2, 15},{3, 15},{3, 14},{4, 14},{4, 15},{5, 15},{5, 14},{6, 14},{6, 15},{7, 15},{7, 14},{8, 14},{8, 15},{9, 15},{9, 14},{10, 14},{10, 15},{11, 15},{11, 14},{12, 14},{12, 15},{13, 15},{13, 14},{11, 4},{10, 4},{9, 4},{8, 4},{8, 5},{9, 5},{10, 5},{11, 5},{8, 6},{9, 6},{10, 6},{11, 6},{11, 7},{10, 7},{9, 7},{8, 7},{8, 8},{9, 8},{10, 8},{11, 8},{11, 9},{10, 9},{9, 9},{8, 9},{8, 10},{9, 10},{10, 10},{11, 10},{11, 11},{10, 11},{9, 11},{8, 11},{8, 12},{9, 12},{10, 12},{11, 12},{11, 13},{10, 13},{9, 13},{8, 13},{8, 16},{9, 16},{10, 16},{11, 16},{11, 17},{10, 17},{9, 17},{8, 17},{8, 18},{9, 18},{10, 18},{11, 18},{11, 19},{10, 19},{9, 19},{8, 19},{8, 20},{9, 20},{10, 20},{11, 20},{11, 21},{10, 21},{9, 21},{8, 21},{6, 22},{6, 23},{7, 23},{7, 22},{8, 22},{8, 23},{9, 23},{9, 22},{10, 22},{10, 23},{11, 23},{11, 22},{12, 22},{12, 23},{13, 23},{13, 22}}; //Big_4
const byte * const Big_Five[142][2] PROGMEM = {{13, 4},{13, 5},{12, 5},{12, 4},{11, 4},{11, 5},{10, 5},{10, 4},{9, 4},{9, 5},{8, 5},{8, 4},{7, 4},{7, 5},{6, 5},{6, 4},{5, 4},{5, 5},{4, 5},{4, 4},{3, 4},{3, 5},{2, 5},{2, 4},{1, 4},{1, 5},{0, 4},{0, 5},{0, 6},{1, 6},{2, 6},{3, 6},{3, 7},{2, 7},{1, 7},{0, 7},{0, 8},{1, 8},{2, 8},{3, 8},{3, 9},{2, 9},{1, 9},{0, 9},{0, 10},{1, 10},{2, 10},{3, 10},{3, 11},{2, 11},{1, 11},{0, 11},{0, 12},{0, 13},{1, 13},{1, 12},{2, 12},{2, 13},{3, 13},{3, 12},{4, 12},{4, 13},{5, 13},{5, 12},{6, 12},{6, 13},{7, 13},{7, 12},{8, 12},{8, 13},{9, 14},{9, 13},{9, 12},{10, 12},{11, 12},{12, 13},{11, 13},{10, 13},{10, 14},{11, 14},{12, 14},{13, 14},{13, 15},{12, 15},{11, 15},{10, 15},{10, 16},{11, 16},{12, 16},{13, 16},{13, 17},{12, 17},{11, 17},{10, 17},{10, 18},{11, 18},{12, 18},{13, 18},{13, 19},{12, 19},{11, 19},{10, 19},{10, 20},{11, 20},{12, 20},{13, 20},{13, 21},{12, 21},{12, 22},{11, 23},{11, 22},{11, 21},{10, 21},{10, 22},{10, 23},{9, 23},{9, 22},{9, 21},{8, 22},{8, 23},{7, 23},{7, 22},{6, 22},{6, 23},{5, 23},{5, 22},{4, 21},{4, 22},{4, 23},{3, 23},{3, 22},{3, 21},{3, 20},{2, 20},{2, 21},{2, 22},{2, 23},{1, 22},{1, 21},{1, 20},{0, 20},{0, 21}}; //Big_5
const byte * const Big_Six[159][2] PROGMEM = {{11, 5},{11, 4},{10, 4},{10, 5},{9, 5},{9, 4},{8, 4},{8, 5},{7, 5},{7, 4},{6, 4},{6, 5},{6, 6},{5, 7},{5, 6},{5, 5},{5, 4},{4, 4},{3, 5},{2, 6},{1, 7},{0, 8},{0, 9},{1, 8},{2, 7},{3, 6},{4, 5},{4, 6},{3, 7},{2, 8},{1, 9},{0, 10},{0, 11},{1, 10},{2, 9},{3, 8},{4, 7},{4, 8},{3, 9},{2, 10},{1, 11},{0, 12},{0, 13},{1, 12},{2, 11},{3, 10},{3, 11},{2, 12},{1, 13},{0, 14},{0, 15},{1, 14},{2, 13},{3, 12},{3, 13},{2, 14},{1, 15},{0, 16},{0, 17},{1, 16},{2, 15},{3, 14},{3, 15},{2, 16},{1, 17},{0, 18},{0, 19},{1, 18},{2, 17},{3, 16},{3, 17},{2, 18},{1, 19},{0, 20},{0, 21},{1, 20},{2, 19},{3, 18},{3, 19},{2, 20},{1, 21},{1, 22},{2, 21},{3, 20},{3, 21},{2, 22},{2, 23},{3, 22},{4, 21},{4, 22},{3, 23},{4, 23},{5, 23},{5, 22},{6, 22},{6, 23},{7, 23},{7, 22},{8, 22},{8, 23},{9, 23},{10, 23},{11, 23},{12, 22},{13, 21},{13, 20},{12, 21},{11, 22},{10, 22},{11, 21},{12, 20},{13, 19},{13, 18},{12, 19},{11, 20},{10, 21},{9, 22},{9, 21},{10, 20},{11, 19},{12, 18},{13, 17},{13, 16},{12, 17},{11, 18},{10, 19},{10, 18},{11, 17},{12, 16},{13, 15},{13, 14},{12, 15},{11, 16},{10, 17},{10, 16},{11, 15},{12, 14},{12, 13},{11, 14},{10, 15},{10, 14},{11, 13},{11, 12},{10, 13},{9, 14},{9, 13},{10, 12},{9, 12},{8, 12},{8, 13},{7, 13},{7, 12},{6, 12},{6, 13},{5, 13},{5, 12},{4, 12},{4, 13},{4, 14}}; //Big_6
const byte * const Big_Seven[114][2] PROGMEM = {{0, 4},{0, 5},{0, 6},{0, 7},{1, 7},{1, 6},{1, 5},{1, 4},{2, 4},{2, 5},{2, 6},{2, 7},{3, 7},{3, 6},{3, 5},{3, 4},{4, 4},{4, 5},{5, 5},{5, 4},{6, 4},{6, 5},{7, 5},{7, 4},{8, 4},{8, 5},{9, 5},{9, 4},{10, 4},{11, 4},{10, 5},{10, 6},{11, 5},{12, 4},{13, 4},{12, 5},{11, 6},{10, 7},{10, 8},{11, 7},{12, 6},{13, 5},{13, 6},{12, 7},{11, 8},{10, 9},{9, 10},{8, 11},{7, 12},{6, 13},{5, 14},{4, 15},{4, 16},{4, 17},{4, 18},{4, 19},{4, 20},{4, 21},{4, 22},{4, 23},{5, 23},{5, 22},{5, 21},{5, 20},{5, 19},{5, 18},{5, 17},{5, 16},{5, 15},{6, 14},{7, 13},{8, 12},{9, 11},{10, 10},{11, 9},{12, 8},{13, 7},{13, 8},{12, 9},{11, 10},{10, 11},{9, 12},{8, 13},{7, 14},{6, 15},{6, 16},{6, 17},{6, 18},{6, 19},{6, 20},{6, 21},{6, 22},{6, 23},{7, 23},{7, 22},{7, 21},{7, 20},{7, 19},{7, 18},{7, 17},{7, 16},{7, 15},{8, 14},{9, 13},{10, 12},{11, 11},{12, 10},{13, 9},{13, 10},{12, 11},{11, 12},{10, 13},{9, 14},{8, 15}}; //Big_7
const byte * const Big_Eight[180][2] PROGMEM = {{9, 11},{10, 11},{11, 11},{12, 11},{13, 10},{12, 10},{11, 10},{10, 10},{10, 9},{11, 9},{12, 9},{13, 9},{13, 8},{12, 8},{11, 8},{10, 8},{10, 7},{11, 7},{12, 7},{13, 7},{13, 6},{12, 5},{12, 6},{11, 6},{11, 5},{11, 4},{10, 4},{10, 5},{10, 6},{9, 6},{9, 5},{9, 4},{8, 4},{8, 5},{7, 5},{7, 4},{6, 4},{6, 5},{5, 5},{5, 4},{4, 4},{4, 5},{3, 4},{2, 4},{3, 5},{4, 6},{3, 6},{2, 5},{1, 5},{2, 6},{3, 7},{2, 7},{1, 6},{0, 6},{0, 7},{1, 7},{2, 8},{3, 8},{3, 9},{2, 9},{1, 9},{1, 8},{0, 8},{0, 9},{0, 10},{1, 10},{2, 10},{3, 10},{4, 11},{3, 11},{2, 11},{1, 11},{2, 12},{2, 13},{3, 13},{3, 12},{4, 12},{4, 13},{5, 13},{5, 12},{6, 12},{6, 13},{7, 13},{7, 12},{8, 12},{8, 13},{9, 14},{9, 13},{9, 12},{10, 12},{11, 12},{11, 13},{10, 13},{10, 14},{11, 14},{12, 14},{13, 15},{12, 15},{11, 15},{10, 15},{10, 16},{11, 16},{12, 16},{13, 16},{13, 17},{12, 17},{11, 17},{10, 17},{10, 18},{11, 18},{12, 18},{13, 18},{13, 19},{12, 19},{11, 19},{10, 19},{10, 20},{11, 20},{12, 20},{13, 20},{13, 21},{12, 21},{12, 22},{11, 21},{11, 22},{11, 23},{10, 21},{10, 22},{10, 23},{9, 21},{9, 22},{9, 23},{8, 23},{8, 22},{7, 22},{7, 23},{6, 23},{6, 22},{5, 22},{5, 23},{4, 23},{4, 22},{4, 21},{3, 23},{2, 23},{1, 22},{2, 22},{3, 22},{3, 21},{2, 21},{1, 21},{0, 21},{0, 20},{1, 20},{2, 20},{3, 20},{3, 19},{2, 19},{1, 19},{0, 19},{0, 18},{1, 18},{2, 18},{3, 18},{3, 17},{2, 17},{1, 17},{0, 17},{0, 16},{1, 16},{2, 16},{3, 16},{3, 15},{2, 15},{1, 15},{0, 15},{1, 14},{2, 14},{3, 14},{4, 14}}; //Big_8
const byte * const Big_Nine[151][2] PROGMEM = {{9, 13},{9, 12},{9, 11},{8, 12},{8, 13},{7, 13},{7, 12},{6, 12},{6, 13},{5, 13},{5, 12},{4, 11},{4, 12},{4, 13},{3, 13},{2, 13},{3, 12},{3, 11},{2, 12},{1, 12},{2, 11},{3, 10},{3, 9},{2, 10},{1, 11},{0, 11},{1, 10},{2, 9},{3, 8},{3, 7},{2, 8},{1, 9},{0, 10},{0, 9},{1, 8},{2, 7},{3, 6},{3, 5},{2, 6},{1, 7},{0, 8},{0, 7},{0, 6},{1, 6},{1, 5},{2, 5},{2, 4},{3, 4},{4, 4},{4, 5},{4, 6},{5, 5},{5, 4},{6, 4},{6, 5},{7, 5},{7, 4},{8, 4},{8, 5},{9, 6},{9, 5},{9, 4},{10, 4},{11, 4},{10, 5},{11, 5},{12, 5},{13, 6},{12, 6},{11, 6},{10, 6},{10, 7},{11, 7},{12, 7},{13, 7},{13, 8},{12, 8},{11, 8},{10, 8},{10, 9},{11, 9},{12, 9},{13, 9},{13, 10},{12, 10},{11, 10},{10, 10},{10, 11},{11, 11},{12, 11},{13, 11},{13, 12},{12, 12},{11, 12},{10, 12},{10, 13},{11, 13},{12, 13},{13, 13},{13, 14},{12, 14},{11, 14},{10, 14},{10, 15},{11, 15},{12, 15},{13, 15},{13, 16},{12, 16},{11, 16},{10, 16},{10, 17},{11, 17},{12, 17},{13, 17},{13, 18},{12, 18},{11, 18},{10, 18},{9, 19},{10, 19},{11, 19},{12, 19},{13, 19},{12, 20},{11, 20},{10, 20},{9, 20},{8, 20},{7, 21},{8, 21},{9, 21},{10, 21},{11, 21},{10, 22},{9, 22},{8, 22},{7, 22},{6, 22},{5, 22},{4, 22},{3, 22},{2, 22},{2, 23},{3, 23},{4, 23},{5, 23},{6, 23},{7, 23},{8, 23},{9, 23}}; //Big_9
const byte * const Big_Delete[42][2] PROGMEM = {{0, 4},{3, 4},{0, 7},{0, 10},{3, 7},{6, 4},{9, 4},{6, 7},{3, 10},{0, 13},{0, 16},{3, 13},{6, 10},{9, 7},{12, 4},{15, 4},{12, 7},{9, 10},{6, 13},{3, 16},{0, 19},{0, 23},{3, 19},{6, 16},{9, 13},{12, 10},{15, 7},{15, 10},{12, 13},{9, 16},{6, 19},{3, 23},{6, 23},{9, 19},{12, 16},{15, 13},{15, 16},{12, 19},{9, 23},{12, 23},{15, 19},{15, 23}}; //Big_Delete
 
void setup()
{
SPI.setBitOrder(MSBFIRST);
SPI.setDataMode(SPI_MODE0);
SPI.setClockDivider(SPI_CLOCK_DIV2);

noInterrupts();

TCCR1A = B00000000;
TCCR1B = B00001011;
TIMSK1 = B00000010;
OCR1A = 15;

pinMode(latch_pin, OUTPUT);
//pinMode(blank_pin, OUTPUT);
pinMode(data_pin, OUTPUT);
pinMode(clock_pin, OUTPUT);

pinMode(RowA_Pin, OUTPUT);
pinMode(RowB_Pin, OUTPUT);
pinMode(RowC_Pin, OUTPUT);
pinMode(RowD_Pin, OUTPUT);
//pinMode(OE_Pin, OUTPUT);

//digitalWrite(OE_Pin, HIGH);
SPI.begin();
interrupts();
Wire.begin();
fill_colour_wheel();

// Print colon between second and minute

xyfillRectangle(0, 0, 24, 15, 25, 16, redcolor);  //void xyfillRectangle(uint8_t xoffset,  uint8_t yoffset, uint8_t y1, uint8_t x1, uint8_t y2, uint8_t x2, Color color)
xyfillRectangle(0, 0, 27, 15, 28, 16, redcolor);  //void xyfillRectangle(uint8_t xoffset,  uint8_t yoffset, uint8_t y1, uint8_t x1, uint8_t y2, uint8_t x2, Color color)

// Print time '00:00:00' when start-up

HandwrittenNumber(SMALL_NUMBER, 24, 20, 0, 1, redcolor, 10); //HandwrittenNumber(byte sizenumber, byte xoffset, byte yoffset, byte number, bool hwclock, Color color, int delaytime)
HandwrittenNumber(SMALL_NUMBER, 16, 20, 0, 1, greencolor, 10); //HandwrittenNumber(byte sizenumber, byte xoffset, byte yoffset, byte number, bool hwclock, Color color, int delaytime) 
HandwrittenNumber(SMALL_NUMBER, 8, 20, 0, 0, greencolor, 10); //HandwrittenNumber(byte sizenumber, byte xoffset, byte yoffset, byte number, bool hwclock, Color color, int delaytime)
HandwrittenNumber(SMALL_NUMBER, 0, 20, 0, 0, redcolor, 10); //HandwrittenNumber(byte sizenumber, byte xoffset, byte yoffset, byte number, bool hwclock, Color color, int delaytime)        
HandwrittenNumber(BIG_NUMBER, 16, 0, 0, 0, greencolor, 10); // HandwrittenNumber(byte sizenumber, byte xoffset, byte yoffset, byte number, bool hwclock, Color color, int delaytime)
HandwrittenNumber(BIG_NUMBER, 0, 0, 0, 0, redcolor, 10); // HandwrittenNumber(byte sizenumber, byte xoffset, byte yoffset, byte number, bool hwclock, Color color, int delaytime)  
}

void loop()
{

Handwritten_S1();
Handwritten_S0();
Handwritten_M1();
Handwritten_M0();
Handwritten_H1();
Handwritten_H0();
}

void LED(int X, int Y, int R, int G)
{
  X = constrain(X, 0, Size_X - 1); 
  Y = constrain(Y, 0, Size_Y - 1);
  
  R = constrain(R, 0, (1 << BAM_RESOLUTION) - 1);
  G = constrain(G, 0, (1 << BAM_RESOLUTION) - 1); 

  int WhichByte = int(Y*4+ X/8);
  int WhichBit = 7-(X%8);

  for (byte BAM = 0; BAM < BAM_RESOLUTION; BAM++) 
  {
    bitWrite(red[BAM][WhichByte], WhichBit, bitRead(R, BAM));

    bitWrite(green[BAM][WhichByte], WhichBit, bitRead(G, BAM));
  }

}

void rowScan(byte row)
{
  
  if (row & 0x01) PORTA |= _BV(RowA_Pin_Bit);   //PORTA |= _BV(0)
    else PORTA &= ~_BV(RowA_Pin_Bit);           //PORTA &= ~_BV(0)
  
  if (row & 0x02) PORTA |= _BV(RowB_Pin_Bit);   //PORTA |= _BV(2)
    else PORTA &= ~_BV(RowB_Pin_Bit);           //PORTA &= ~_BV(2)

  if (row & 0x04) PORTA |= _BV(RowC_Pin_Bit);   //PORTA |= _BV(4)
    else PORTA &= ~_BV(RowC_Pin_Bit);           //PORTA &= ~_BV(4)

  if (row & 0x08) PORTA |= _BV(RowD_Pin_Bit);   //PORTA |= _BV(6)
    else PORTA &= ~_BV(RowD_Pin_Bit);           //PORTA &= ~_BV(6)
}

ISR(TIMER1_COMPA_vect)
{
  
  PORTE |= ((1<<Blank_Pin_Bit));                  // Set BLANK PIN high - 74HC595
  //PORTC |= _BV(OE_Pin_Bit);                       // Set OUTPUT ENABLE high - 74HC238
  
  if(BAM_Counter==4)
  BAM_Bit++;
  else
  if(BAM_Counter==12)
  BAM_Bit++;
  else
  if(BAM_Counter==28)
  BAM_Bit++;
  
  BAM_Counter++;
  
  switch (BAM_Bit)
  {
    case 0:
      //Red
      
        myTransfer(red[0][level + 0]);
        myTransfer(red[0][level + 1]);
        myTransfer(red[0][level + 2]);
        myTransfer(red[0][level + 3]);
        myTransfer(red[0][level + 64]);
        myTransfer(red[0][level + 65]);
        myTransfer(red[0][level + 66]);
        myTransfer(red[0][level + 67]);

      //Green
        
        myTransfer(green[0][level + 0]);
        myTransfer(green[0][level + 1]);
        myTransfer(green[0][level + 2]);
        myTransfer(green[0][level + 3]);
        myTransfer(green[0][level + 64]);
        myTransfer(green[0][level + 65]);
        myTransfer(green[0][level + 66]);
        myTransfer(green[0][level + 67]);

      break;
    case 1:       
      //Red

        myTransfer(red[1][level + 0]);
        myTransfer(red[1][level + 1]);
        myTransfer(red[1][level + 2]);
        myTransfer(red[1][level + 3]);  
        myTransfer(red[1][level + 64]);
        myTransfer(red[1][level + 65]);
        myTransfer(red[1][level + 66]);
        myTransfer(red[1][level + 67]);             
      //Green

        myTransfer(green[1][level + 0]);
        myTransfer(green[1][level + 1]);
        myTransfer(green[1][level + 2]);
        myTransfer(green[1][level + 3]);        
        myTransfer(green[1][level + 64]);
        myTransfer(green[1][level + 65]);
        myTransfer(green[1][level + 66]);
        myTransfer(green[1][level + 67]);
        
      break;
    case 2:     
      //Red

        myTransfer(red[2][level + 0]);
        myTransfer(red[2][level + 1]);
        myTransfer(red[2][level + 2]);
        myTransfer(red[2][level + 3]);      
        myTransfer(red[2][level + 64]);
        myTransfer(red[2][level + 65]);
        myTransfer(red[2][level + 66]);
        myTransfer(red[2][level + 67]);
                      
       //Green

        myTransfer(green[2][level + 0]);
        myTransfer(green[2][level + 1]);
        myTransfer(green[2][level + 2]);
        myTransfer(green[2][level + 3]);       
        myTransfer(green[2][level + 64]);
        myTransfer(green[2][level + 65]);
        myTransfer(green[2][level + 66]);
        myTransfer(green[2][level + 67]);

      break;
    case 3:
      //Red

        myTransfer(red[3][level + 0]);
        myTransfer(red[3][level + 1]);
        myTransfer(red[3][level + 2]);
        myTransfer(red[3][level + 3]);               
        myTransfer(red[3][level + 64]);
        myTransfer(red[3][level + 65]);
        myTransfer(red[3][level + 66]);
        myTransfer(red[3][level + 67]);    

      //Green

        myTransfer(green[3][level + 0]);
        myTransfer(green[3][level + 1]);
        myTransfer(green[3][level + 2]);
        myTransfer(green[3][level + 3]);             
        myTransfer(green[3][level + 64]);
        myTransfer(green[3][level + 65]);
        myTransfer(green[3][level + 66]);
        myTransfer(green[3][level + 67]);
        
        if(BAM_Counter==60){
        BAM_Counter=0;
        BAM_Bit=0;
      }
    break;
  }

  rowScan(row);
  
  PORTE |= 1<<Latch_Pin_Bit;
  PORTE &= ~(1<<Latch_Pin_Bit);
  PORTE &= ~(1<<Blank_Pin_Bit);       // Set BLANK PIN low - 74HC595
  //PORTC &= ~_BV(OE_Pin_Bit);          // Set OUTPUT ENABLE low - 74HC238
  
  row++;
  level = row<<2;
  if(row==16)
  row=0;
  if(level==64)
  level=0;
  
  DDRE |= _BV (Blank_Pin_Bit);    // pinMode (blank_pin, OUTPUT);
  //DDRC |= _BV (OE_Pin_Bit);       // pinMode (OE_Pin, OUTPUT);

}

inline static uint8_t myTransfer(uint8_t C_data){
  SPDR = C_data;
  asm volatile("nop"); 
  asm volatile("nop"); 
  asm volatile("nop"); 
  asm volatile("nop"); 
}


void clearfast ()
{
    memset(red, 0, sizeof(red[0][0]) * 4 * 128);
    memset(green, 0, sizeof(green[0][0]) * 4 * 128);
}


void fillTable(byte R, byte G)
{
    for (byte x=0; x<32; x++)
    {
      for (byte y=0; y<32; y++)
      {
        LED(x, y, R, G);
      }
    }
}

//*******************************************************MK4*****************************************************//

//FAST SINE APPROX
float mySin(float x){
  float sinr = 0;
  uint8_t g = 0;

  while(x > myPI){
    x -= 2*myPI; 
    g = 1;
  }

  while(!g&(x < -myPI)){
    x += 2*myPI;
  }

  sinr = myDPI*x - myDPI2*x*myAbs(x);
  sinr = 0.225*(sinr*myAbs(sinr)-sinr)+sinr;

  return sinr;
}

//FAST COSINE APPROX
float myCos(float x){
  return mySin(x+myPI/2);
}

float myTan(float x){
  return mySin(x)/myCos(x);
}

//SQUARE ROOT APPROX
float mySqrt(float in){
  int16_t d = 0;
  int16_t in_ = in;
  float result = 2;
  
  for(d = 0; in_ > 0; in_ >>= 1){
    d++;
  }
  
  for(int16_t i = 0; i < d/2; i++){
    result = result*2;
  }
  
  for(int16_t i = 0; i < 3; i++){
    result = 0.5*(in/result + result);
  }
  
  return result;
}

//MAP NUMBERS TO NEW RANGE
float myMap(float in, float inMin, float inMax, float outMin, float outMax){
  float out;
  out = (in-inMin)/(inMax-inMin)*(outMax-outMin) + outMin;
  return out;
}

//ROUND A NUMBER
int16_t myRound(float in){
  int8_t s = in/myAbs(in);
  return (int16_t)(s*(myAbs(in) + 0.5));
}

//ABSOLUTE VALUE
float myAbs(float in){
  return (in)>0?(in):-(in);
} 

void fill_colour_wheel(void) 
{
  float red, green;
  float c, s;
  int32_t phase = 0;
  int16_t I = 0;

  while (phase < COLOUR_WHEEL_LENGTH) 
  {
    s = (1 << BAM_RESOLUTION)*mySin(myPI*(3 * phase - I*COLOUR_WHEEL_LENGTH) / (2 * COLOUR_WHEEL_LENGTH));
    c = (1 << BAM_RESOLUTION)*myCos(myPI*(3 * phase - I*COLOUR_WHEEL_LENGTH) / (2 * COLOUR_WHEEL_LENGTH));

    red = (I == 0 ? 1 : 0)*s + (I == 1 ? 1 : 0)*c;
    green = (I == 1 ? 1 : 0)*s + (I == 2 ? 1 : 0)*c;

    colourR[phase] = red;
    colourG[phase] = green;

    if (++phase >= (1 + I)*COLOUR_WHEEL_LENGTH / 3) 
      I++;
  }
}

void get_colour(int16_t p, uint8_t *R, uint8_t *G)
{
  if (p >= (COLOUR_WHEEL_LENGTH-1))         
    p -= ((p-= (COLOUR_WHEEL_LENGTH-1)==0) ? COLOUR_WHEEL_LENGTH-3 : COLOUR_WHEEL_LENGTH-1);         

    
  *R = colourR[p];
  *G = colourG[p];
}

void get_next_colour(uint8_t *R, uint8_t *G)
{
  if (++ColPos >= (COLOUR_WHEEL_LENGTH))   
    ColPos -= (COLOUR_WHEEL_LENGTH);     

  *R = colourR[ColPos];
  *G = colourG[ColPos];
}

void increment_colour_pos(uint8_t i)
{
  colourPos += i;
  while (colourPos >= (COLOUR_WHEEL_LENGTH))   
  {
    colourPos -= (COLOUR_WHEEL_LENGTH);       
  }
}


int checkConstrains(int value, int min, int max) 
{
  if(value < min) 
    {
      return min;
    } 
  else if (value > max) 
    {
      return max;
    } 
  else 
    {
      return value;
    }
}

void xyfillRectangle(uint8_t xoffset,  uint8_t yoffset, uint8_t y1, uint8_t x1, uint8_t y2, uint8_t x2, Color color)
{
  for (uint8_t y = y1; y <= y2; y++) 
    {
      for (uint8_t x = x1; x <= x2; x++) 
        {
          LED(xoffset + x, yoffset + y, color.red, color.green);
  
        }
    }         
}

// Convert decimal numbers to binary coded decimal
byte decToBcd(byte val)
{
  return ( (val / 10 * 16) + (val % 10) );
}

// Convert binary coded decimal to decimal numbers
byte bcdToDec(byte val)
{
  return ( (val / 16 * 10) + (val % 16) );
}

void ReadDS3231Time(byte *second, byte *minute, byte *hour, byte *dayOfWeek, byte *dayOfMonth, byte *month, byte *year)
{
  Wire.beginTransmission(DS3231_I2C_ADDRESS);
  Wire.write(0); // Set DS3231 register pointer to 00h
  Wire.endTransmission();

  // Request seven bytes of data from DS3231 starting from register 00h
  
  Wire.requestFrom(DS3231_I2C_ADDRESS, 7);
  *second = (Wire.read() & 0x7f);
  *minute = (Wire.read());
  *hour = (Wire.read() & 0x3f);
}

void Handwritten_S1()
{ 
  if ( (unsigned long) (micros() - samplingtime) > 3  )
  {
    ReadDS3231Time(&csecond, &cminute, &chour, &cdayOfWeek, &cdayOfMonth, &cmonth, &cyear);                
    s1 = (csecond & 0x0f);             
    if (s1 != prves1)  
      {
      if (s1==0 || s1==5)
        {                   
          DoEraserRec(SMALL_NUMBER, 24, 20, 1, greencolor, 15);         // DoEraserRec(byte sizenumber, uint8_t xoffset, uint8_t yoffset, bool hwclock, Color color, int delaytime)
          HandwrittenNumber(SMALL_NUMBER, 24, 20, s1, 1, redcolor, 10); // HandwrittenNumber(byte sizenumber, byte xoffset, byte yoffset, byte number, bool hwclock, Color color, int delaytime)               
          prves1 = s1;         
          }
      }
   
      samplingtime = micros(); 
    }
}        

void Handwritten_S0()
{ 
  if ( (unsigned long) (micros() - samplingtime) > 3  )
  {
    ReadDS3231Time(&csecond, &cminute, &chour, &cdayOfWeek, &cdayOfMonth, &cmonth, &cyear);    
      s0 = ((csecond >> 4) & 0x0f); 
      if (s0 != prves0)  
        {                     
          DoEraserRec(SMALL_NUMBER, 16, 20, 1, redcolor, 15);             // DoEraserRec(byte sizenumber, uint8_t xoffset, uint8_t yoffset, bool hwclock, Color color, int delaytime)
          HandwrittenNumber(SMALL_NUMBER, 16, 20, s0, 1, greencolor, 10); // HandwrittenNumber(byte sizenumber, byte xoffset, byte yoffset, byte number, bool hwclock, Color color, int delaytime)            
          prves0 = s0;        
        } 
      samplingtime = micros(); 
    }
}

void Handwritten_M1()
{ 
  if ( (unsigned long) (micros() - samplingtime) > 3  )
  {
    ReadDS3231Time(&csecond, &cminute, &chour, &cdayOfWeek, &cdayOfMonth, &cmonth, &cyear);       
    m1 = (cminute & 0x0f);
    if (m1 != prvem1)  
      {      
        DoEraserRec(SMALL_NUMBER, 8, 20, 0, redcolor, 15);              // DoEraserRec(byte sizenumber, uint8_t xoffset, uint8_t yoffset, bool hwclock, Color color, int delaytime)
        HandwrittenNumber(SMALL_NUMBER, 8, 20, m1, 0, greencolor, 10);  // HandwrittenNumber(byte sizenumber, byte xoffset, byte yoffset, byte number, bool hwclock, Color color, int delaytime)
        prvem1 = m1;
      }
      samplingtime = micros(); 
    }
}   

void Handwritten_M0()
{ 
  if ( (unsigned long) (micros() - samplingtime) > 3  )
  {
    ReadDS3231Time(&csecond, &cminute, &chour, &cdayOfWeek, &cdayOfMonth, &cmonth, &cyear);            
    m0 = ((cminute >> 4) & 0x0f);
    if (m0!=prvem0)  
      {         
        DoEraserRec(SMALL_NUMBER, 0, 20, 0, greencolor, 15);          // DoEraserRec(byte sizenumber, uint8_t xoffset, uint8_t yoffset, bool hwclock, Color color, int delaytime)
        HandwrittenNumber(SMALL_NUMBER, 0, 20, m0, 0, redcolor, 10);  // HandwrittenNumber(byte sizenumber, byte xoffset, byte yoffset, byte number, bool hwclock, Color color, int delaytime)      
        prvem0 = m0;
      }
      samplingtime = micros(); 
    }
} 

void Handwritten_H1()
{ 
  if ( (unsigned long) (micros() - samplingtime) > 3  )
  {
    ReadDS3231Time(&csecond, &cminute, &chour, &cdayOfWeek, &cdayOfMonth, &cmonth, &cyear);       
    h1 = (chour & 0x0f);
    if (h1 != prveh1)  
      {  
        DoEraserRec(BIG_NUMBER, 16, 0, 0, redcolor, 15);            // DoEraserRec(byte sizenumber, uint8_t xoffset, uint8_t yoffset, bool hwclock, Color color, int delaytime)
        HandwrittenNumber(BIG_NUMBER, 16, 0, h1, 0, greencolor, 5); // HandwrittenNumber(byte sizenumber, byte xoffset, byte yoffset, byte number, bool hwclock, Color color, int delaytime)
        prveh1 = h1;
      }
      samplingtime = micros(); 
    }
}       

void Handwritten_H0()
{ 
  if ( (unsigned long) (micros() - samplingtime) > 3  )
  {
    ReadDS3231Time(&csecond, &cminute, &chour, &cdayOfWeek, &cdayOfMonth, &cmonth, &cyear);      
    h0 = ((chour >> 4) & 0x0f);    
    if (h0 != prveh0)  
      {  
        DoEraserRec(BIG_NUMBER, 0, 0, 0, greencolor, 15);         // DoEraserRec(byte sizenumber, uint8_t xoffset, uint8_t yoffset, bool hwclock, Color color, int delaytime)     
        HandwrittenNumber(BIG_NUMBER, 0, 0, h0, 0, redcolor, 5);  // HandwrittenNumber(byte sizenumber, byte xoffset, byte yoffset, byte number, bool hwclock, Color color, int delaytime)
        prveh0 = h0;
      }
      samplingtime = micros(); 
    }
} 

void HandwrittenNumber(byte sizenumber, byte xoffset, byte yoffset, byte number, bool hwclock, Color color, int delaytime)
{
  if (sizenumber == INV_NUMBER)
  {
    switch (number)
    {
      case 0: DrawDigit(INV_NUMBER, Inv_Zero, 86, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 0 ' //
      case 1: DrawDigit(INV_NUMBER, Inv_One, 100, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 1 ' //
      case 2: DrawDigit(INV_NUMBER, Inv_Two, 90, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 2 ' //
      case 3: DrawDigit(INV_NUMBER, Inv_Three, 92, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 3 ' //
      case 4: DrawDigit(INV_NUMBER, Inv_Four, 87, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 4 ' //
      case 5: DrawDigit(INV_NUMBER, Inv_Five, 89, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 5 ' //
      case 6: DrawDigit(INV_NUMBER, Inv_Six, 87, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 6 ' //
      case 7: DrawDigit(INV_NUMBER, Inv_Seven, 97, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 7 ' //
      case 8: DrawDigit(INV_NUMBER, Inv_Eight, 83, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 8 ' //
      case 9: DrawDigit(INV_NUMBER, Inv_Nine, 87, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 9 ' //
      case 10: DrawDigit(INV_NUMBER, Inv_Delete, 128, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 10 ' // 
    }
  }
  else if (sizenumber == SMALL_NUMBER)
  {
  switch (number)
    {
      case 0: DrawDigit(SMALL_NUMBER, Zero, 42, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 0 ' //
      case 1: DrawDigit(SMALL_NUMBER, One, 28, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 1 ' //
      case 2: DrawDigit(SMALL_NUMBER, Two, 38, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 2 ' //
      case 3: DrawDigit(SMALL_NUMBER, Three, 36, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 3 ' //
      case 4: DrawDigit(SMALL_NUMBER, Four, 41, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 4 ' //
      case 5: DrawDigit(SMALL_NUMBER, Five, 39, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 5 ' //
      case 6: DrawDigit(SMALL_NUMBER, Six, 41, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 6 ' //
      case 7: DrawDigit(SMALL_NUMBER, Seven, 31, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 7 ' //
      case 8: DrawDigit(SMALL_NUMBER, Eight, 45, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 8 ' //
      case 9: DrawDigit(SMALL_NUMBER, Nine, 41, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 9 ' //
      case 10: DrawDigit(SMALL_NUMBER, Delete, 39, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 10 ' //  
    }
  }
  else // BIG_NUMBER
  {
  switch (number)
    {
      case 0: DrawDigit(BIG_NUMBER, Big_Zero, 192, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 0 ' //
      case 1: DrawDigit(BIG_NUMBER, Big_One, 106, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 1 ' //
      case 2: DrawDigit(BIG_NUMBER, Big_Two, 145, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 2 ' //
      case 3: DrawDigit(BIG_NUMBER, Big_Three, 136, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 3 ' //
      case 4: DrawDigit(BIG_NUMBER, Big_Four, 142, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 4 ' //
      case 5: DrawDigit(BIG_NUMBER, Big_Five, 142, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 5 ' //
      case 6: DrawDigit(BIG_NUMBER, Big_Six, 159, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 6 ' //
      case 7: DrawDigit(BIG_NUMBER, Big_Seven, 114, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 7 ' //
      case 8: DrawDigit(BIG_NUMBER, Big_Eight, 180, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 8 ' //
      case 9: DrawDigit(BIG_NUMBER, Big_Nine, 151, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 9 ' //
      case 10: DrawDigit(BIG_NUMBER, Big_Delete, 42, xoffset, yoffset, hwclock, color, delaytime); break; //  Hand-writting character ' 10 ' //    
    }
  }
}

void DrawDigit(byte sizenumber, const byte * const coordinates[][2], byte sizedigit, byte xoffset, byte yoffset, bool hwclock, Color color, int delaytime)
{


if (sizenumber == BIG_NUMBER)
  {  
    for (int i = 0; i < sizedigit; i++)
      {
        if (hwclock)
        LED(xoffset + pgm_read_byte(&coordinates[i][0])+ 2, yoffset + pgm_read_byte(&coordinates[i][1])-4, color.red, color.green);
        else
        LED(xoffset + pgm_read_byte(&coordinates[i][0]), yoffset + pgm_read_byte(&coordinates[i][1])-4, color.red, color.green);
        delay(delaytime);
      }
  }
else if (sizenumber == SMALL_NUMBER)
  {  
    for (int i = 0; i < sizedigit; i++)
      {
        if (hwclock)
        LED(xoffset + pgm_read_byte(&coordinates[i][0]), yoffset + pgm_read_byte(&coordinates[i][1]), color.red, color.green);
        else
        LED(xoffset + pgm_read_byte(&coordinates[i][0]) - 1, yoffset + pgm_read_byte(&coordinates[i][1]), color.red, color.green);
        delay(delaytime);
      }    
  }
else
  {  
    for (int i = 0; i < sizedigit; i++)
      {
        if (hwclock)
        LED(xoffset + pgm_read_byte(&coordinates[i][0])-1, yoffset + pgm_read_byte(&coordinates[i][1])-4, color.red, color.green);
        else
        LED(xoffset + pgm_read_byte(&coordinates[i][0])-1, yoffset + pgm_read_byte(&coordinates[i][1])-4, color.red, color.green);
        delay(delaytime);
      }    
  }
  
}
  
void DoEraserRec(byte sizenumber, uint8_t xoffset, uint8_t yoffset, bool hwclock, Color color, int delaytime)
{

if((sizenumber==SMALL_NUMBER) || (sizenumber==INV_NUMBER))
  {   
    for (int i = 0; i < 39; i++)
    {
      byte x1 = pgm_read_byte(&Delete[i][0]);
      byte y1 = pgm_read_byte(&Delete[i][1]);
      byte x2 = x1 + 1;
      byte y2 = y1 + 1;
      y1 = checkConstrains(y1, 0, 15);
      y2 = checkConstrains(y2, 0, 15);
      if (hwclock)
        {
        x1 = checkConstrains(x1, 1, 7);
        x2 = checkConstrains(x2, 1, 7);
        xyfillRectangle(xoffset, yoffset, y1, x1, y2, x2, color);
        delay(delaytime);
        xyfillRectangle(xoffset, yoffset, y1, x1, y2, x2, clearcolor);
        }
     else
        {
        x1 = checkConstrains(x1, 0, 7);
        x2 = checkConstrains(x2, 0, 7);
        xyfillRectangle(xoffset, yoffset, y1, x1-1, y2, x2-1, color);
        delay(delaytime);
        xyfillRectangle(xoffset, yoffset, y1, x1-1, y2, x2-1, clearcolor);
        }        
    }
  }

if(sizenumber==BIG_NUMBER)
  {   
    for (int i = 0; i < 42; i++)
    {
      byte x1 = pgm_read_byte(&Big_Delete[i][0]);
      byte y1 = pgm_read_byte(&Big_Delete[i][1]);
      byte x2 = x1 + 2;
      byte y2 = y1 + 3;
      y1 = checkConstrains(y1, 4, 23);
      y2 = checkConstrains(y2, 4, 23);
      x1 = checkConstrains(x1, 0, 13);
      x2 = checkConstrains(x2, 0, 13);
      xyfillRectangle(xoffset, yoffset, y1-4, x1, y2-4, x2, color);
      delay(delaytime);
      xyfillRectangle(xoffset, yoffset, y1-4, x1, y2-4, x2, clearcolor);
            
    }
  }  
}
